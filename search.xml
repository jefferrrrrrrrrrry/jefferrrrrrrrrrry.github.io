<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BUAA-OO 第一单元表达式解析</title>
      <link href="/2023/03/15/2023-03-15-BUAA-OO-%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/03/15/2023-03-15-BUAA-OO-%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h2><p>当我拿到第一次作业的时候，我不知所措，一开始不知道如何解析字符串，当理解了递归下降解析文法后，依然无法找到一种合适的方法去存储最基本的项，做不到最基础的（x+1)*(y+2)的计算，还记得那一次作业是在周六晚上才完成的，其中经历了许许多多的重构与折磨。OO要改变的是思维方式，这个过程是很漫长的，有很多方面都不适应，做出的重构就是思路的改变。仅以本博客记录记录我第一单元的经历。</p><h2 id="二、第一单元结构"><a href="#二、第一单元结构" class="headerlink" title="二、第一单元结构"></a>二、第一单元结构</h2><p><strong>2.1 HW1</strong></p><p><strong>2.1.1 设计思路</strong></p><ul><li>采用梯度下降的解析方法（<code>Paser</code>和<code>Lexer</code>）对表达式进行解析，整个表达式分为3层：<code>Expr</code>、<code>Term</code>、<code>Factor</code>，而Factor又包括<code>Number</code>、<code>Power</code>（幂函数）、<code>Expr</code>。</li><li>创建Poly类表示经过文法解析后的Expr，Term，Factor代表的数学多项式含义，Poly有一个Hashmap属性，Special储存了x,y,z的指数，通过将Special作为key映射到不同的value(系数)来储存多项式。通过createPoly()函数可以实例化一个Poly对象。</li><li>同时设置Power，Number类来表示最底层的类，这两个类能直接生成Poly类，而不需要递归调用内部因子的createPoly()函数。Expr生成Poly需要对组成Expr的每个Term调用createPoly()函数，最终把所有的Poly相加(addPoly())或相减(subPoly())</li><li>Term类生成Poly需要调用组成Term的Expr，Power，Number的createPoly()函数，而最终会递归到Power，Number，而这两个类是可以直接生成Poly的，因此不会进入无穷递归。最后把生成的Poly相乘，调用mulPoly()函数完成。</li><li>最后一步，在main里依次调用输入的字符串的递归下降解析，生成了一个Expr对象，再调用Expr的createPoly()方法，就能得到一个Poly的Hashmap，化简输出即完成了第一次作业。</li></ul><p><strong>2.1.2 UML类图</strong></p><img src="/2023/03/15/2023-03-15-BUAA-OO-%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/1.png" class title="P1"><p><strong>2.1.3 类复杂度</strong></p><h4 id="OCavg-Average-opearation-complexity（平均操作复杂度）"><a href="#OCavg-Average-opearation-complexity（平均操作复杂度）" class="headerlink" title="OCavg = Average opearation complexity（平均操作复杂度）"></a><code>OCavg</code> = <code>Average opearation complexity</code>（平均操作复杂度）</h4><h4 id="OCmax-Maximum-operation-complexity（最大操作复杂度）"><a href="#OCmax-Maximum-operation-complexity（最大操作复杂度）" class="headerlink" title="OCmax = Maximum operation complexity（最大操作复杂度）"></a><code>OCmax</code> = <code>Maximum operation complexity</code>（最大操作复杂度）</h4><h4 id="WMC-Weighted-method-complexity（加权方法复杂度）"><a href="#WMC-Weighted-method-complexity（加权方法复杂度）" class="headerlink" title="WMC = Weighted method complexity（加权方法复杂度）"></a><code>WMC</code> = <code>Weighted method complexity</code>（加权方法复杂度）</h4><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Expr</td><td>3.5</td><td>9</td><td>14</td></tr><tr><td>Lexer</td><td>2</td><td>5</td><td>10</td></tr><tr><td>MainClass</td><td>1</td><td>1</td><td>2</td></tr><tr><td>Number</td><td>1</td><td>1</td><td>3</td></tr><tr><td>Parser</td><td>5.25</td><td>8</td><td>21</td></tr><tr><td>Poly</td><td>2.43</td><td>5</td><td>17</td></tr><tr><td>Power</td><td>2.5</td><td>4</td><td>5</td></tr><tr><td>Special</td><td>1</td><td>1</td><td>7</td></tr><tr><td>Term</td><td>2.33</td><td>5</td><td>7</td></tr></tbody></table><p>从图中可以看出<code>Paser</code>和<code>Poly</code>的复杂度较高，这主要是因为程序可以分为解析和计算两大主要部分。解析部分主要由<code>Paser</code>实现，计算部分主要由<code>Poly</code>实现,承担大部分工作而造成的复杂度增加。</p><p><strong>2.1.4 方法复杂度</strong></p><p><strong><code>CogC</code> = <code>Cognitive complexity</code>（认知复杂度）</strong></p><h4 id="ev-G-Essential-cyclomatic-complexity（基本圈复杂度）"><a href="#ev-G-Essential-cyclomatic-complexity（基本圈复杂度）" class="headerlink" title="ev(G) = Essential cyclomatic complexity（基本圈复杂度）"></a><code>ev(G)</code> = <code>Essential cyclomatic complexity</code>（基本圈复杂度）</h4><h4 id="iv-G-Design-complexity（设计复杂度）"><a href="#iv-G-Design-complexity（设计复杂度）" class="headerlink" title="iv(G) = Design complexity（设计复杂度）"></a><code>iv(G)</code> = <code>Design complexity</code>（设计复杂度）</h4><h4 id="v-G-cyclonmatic-complexity（圈复杂度）"><a href="#v-G-cyclonmatic-complexity（圈复杂度）" class="headerlink" title="v(G) = cyclonmatic complexity（圈复杂度）"></a><code>v(G)</code> = <code>cyclonmatic complexity</code>（圈复杂度）</h4><table><thead><tr><th>Method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Expr.Expr()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.addTerm(Term, String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.createPoly()</td><td>4</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Expr.print()</td><td>24</td><td>1</td><td>11</td><td>12</td></tr><tr><td>Lexer.Lexer(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.behind()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.getNumber()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Lexer.next()</td><td>10</td><td>2</td><td>7</td><td>9</td></tr><tr><td>Lexer.peek()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MainClass.main(String[])</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MainClass.simplify(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Number.Number(BigInteger)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Number.addNumber(BigInteger)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Number.createPoly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.Parser(Lexer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.parseExpr()</td><td>16</td><td>1</td><td>9</td><td>9</td></tr><tr><td>Parser.parseFactor()</td><td>9</td><td>5</td><td>6</td><td>6</td></tr><tr><td>Parser.parseTerm()</td><td>20</td><td>1</td><td>8</td><td>8</td></tr><tr><td>Poly.Poly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.addPoly(Poly, Poly)</td><td>4</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.getPolys()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.merge()</td><td>8</td><td>1</td><td>5</td><td>5</td></tr><tr><td>Poly.mulPoly(Poly, Poly)</td><td>3</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.setPolys(HashMap&lt;Special,  BigInteger&gt;)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.subPoly(Poly, Poly)</td><td>4</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Power.Power(Integer, char)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Power.createPoly()</td><td>3</td><td>1</td><td>4</td><td>4</td></tr><tr><td>Special.equals(Special)</td><td>1</td><td>1</td><td>1</td><td>3</td></tr><tr><td>Special.getX()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.getY()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.getZ()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setX(Integer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setY(Integer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setZ(Integer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.Term()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.addFactor(Factor)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.createPoly()</td><td>5</td><td>1</td><td>5</td><td>5</td></tr></tbody></table><p>分析可知，<code>Expr.print()</code>和<code>Parser.parseTerm()</code>复杂度较高，解析项和因子情况比较复杂因此导致<code>Parser.parseTerm()</code>复杂度提升。而<code>Expr.print()</code>是因为我过程式编程思想没有完全摒弃导致的，在之后的迭代我将其优化为重写成各个类的<code>toString()</code>来输出结果。</p><p><strong>2.2 HW2</strong></p><p><strong>2.2.1 设计思路</strong></p><ul><li><h5 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h5><p>我选择在解析表达式之前建Func类来存自定义函数替换规则，之后在递归解析表达式过程中遇到自定义函数用字符串替换的方式去除自定义函数，返回表达式因子，为了保证运算优先级，替换后的因子加括号。比如,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">f(x,y)=x*y  (1)</span><br><span class="line">f(y,z)      (2)</span><br><span class="line">替换后    （y）*（z)</span><br></pre></td></tr></table></figure><p>但需要注意的是直接使用String的repalce会出现因为替换有先后顺序，会导致后一个替换<strong>错误替换</strong>前一个替换，例如上面例子，先把x-&gt;y,再把y-&gt;z，会先后得到(y)<em>y和((z))</em>(z)。因此可以为(2)式找一个与(1)式子没有交集的“自变量”，比如{h,j,k}来先替换(2)式中的{x,y,z}，最后完成因子替换后再换回。 <strong>注意，找无关变量不能太随意，比如找{a,b,c}，可能就会替换“cos”中的 ‘c’。</strong></p></li><li><h5 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h5><p>我选择将其作为与幂函数，整数同一“层面”的类，接口为Factor。 相比于上一次作业的架构，只需要将Poly给改进一下，使其能储存系数，x,y,z指数，三角函数及其指数，具体形式如下，可以考虑单独建一个类存x,y,z指数，和Hashmap映射三角函数与指数，再将这个类映射系数。</p><img src="/2023/03/15/2023-03-15-BUAA-OO-%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/4.png" class title="P4"></li></ul><p><strong>2.2.2 UML类图</strong></p><img src="/2023/03/15/2023-03-15-BUAA-OO-%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/2.png" class title="P2"><p><strong>2.2.3 类复杂度</strong></p><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Expr</td><td>1.5</td><td>3</td><td>6</td></tr><tr><td>Func</td><td>1.25</td><td>2</td><td>5</td></tr><tr><td>Lexer</td><td>2.75</td><td>7</td><td>11</td></tr><tr><td>MainClass</td><td>2.33</td><td>4</td><td>7</td></tr><tr><td>Number</td><td>1</td><td>1</td><td>4</td></tr><tr><td>Parser</td><td>6</td><td>11</td><td>30</td></tr><tr><td>Poly</td><td>4.38</td><td>14</td><td>57</td></tr><tr><td>Power</td><td>2.33</td><td>4</td><td>7</td></tr><tr><td>Special</td><td>1.17</td><td>3</td><td>14</td></tr><tr><td>Term</td><td>1.33</td><td>2</td><td>4</td></tr><tr><td>Triangle</td><td>1.67</td><td>2</td><td>5</td></tr></tbody></table><p>类新增了Triangle和Func类，复杂度均不高，因为只是新增了功能并不用承担很复杂的工作。由于调用是自顶向下的，最底层的Poly以及顶层的解析Parser这两个类的复杂度依然很高，这是架构设计导致的必然结果。</p><p><strong>2.2.4 方法复杂度</strong></p><table><thead><tr><th>Method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Expr.Expr()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.addTerm(Term, String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.createPoly()</td><td>4</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Expr.toString()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Func.Func(char,  ArrayList<Character>, Expr)</Character></td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Func.change(ArrayList<Factor>)</Factor></td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Func.getName()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Func.simplify(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.Lexer(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.getNumber()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Lexer.next()</td><td>12</td><td>2</td><td>9</td><td>11</td></tr><tr><td>Lexer.peek()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MainClass.createFunc(String)</td><td>6</td><td>1</td><td>4</td><td>4</td></tr><tr><td>MainClass.main(String[])</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>MainClass.simplify(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Number.Number(BigInteger)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Number.addNumber(BigInteger)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Number.createPoly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Number.toString()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.Parser(Lexer,  ArrayList<Func>)</Func></td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.parseExpr()</td><td>16</td><td>1</td><td>9</td><td>9</td></tr><tr><td>Parser.parseFactor()</td><td>16</td><td>8</td><td>11</td><td>11</td></tr><tr><td>Parser.parseFunc()</td><td>4</td><td>3</td><td>4</td><td>4</td></tr><tr><td>Parser.parseTerm()</td><td>20</td><td>1</td><td>8</td><td>8</td></tr><tr><td>Poly.Poly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.addPoly(Poly, Poly)</td><td>4</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.equals(Object)</td><td>3</td><td>3</td><td>2</td><td>4</td></tr><tr><td>Poly.hashCode()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.merge()</td><td>8</td><td>1</td><td>5</td><td>5</td></tr><tr><td>Poly.mulPoly(Poly, Poly)</td><td>29</td><td>1</td><td>10</td><td>10</td></tr><tr><td>Poly.setPolys(HashMap&lt;Special,  BigInteger&gt;)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.subPoly(Poly, Poly)</td><td>4</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.toString()</td><td>34</td><td>8</td><td>23</td><td>24</td></tr><tr><td>Poly.tri(Special, String)</td><td>10</td><td>1</td><td>9</td><td>9</td></tr><tr><td>Poly.triesx(int)</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.triesy(int)</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.triesz(int)</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Power.Power(Integer, char)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Power.createPoly()</td><td>3</td><td>1</td><td>4</td><td>4</td></tr><tr><td>Power.toString()</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Special.equals(Object)</td><td>4</td><td>3</td><td>6</td><td>8</td></tr><tr><td>Special.getCos()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.getSin()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.getX()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.getY()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.getZ()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.hashCode()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setCos(HashMap&lt;Poly,  Integer&gt;)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setSin(HashMap&lt;Poly,  Integer&gt;)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setX(Integer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setY(Integer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setZ(Integer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.Term()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.addFactor(Factor)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.createPoly()</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Triangle.Triangle(String, Expr, Integer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Triangle.createPoly()</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Triangle.toString()</td><td>1</td><td>1</td><td>2</td><td>2</td></tr></tbody></table><p><strong>2.3 HW3</strong></p><p><strong>2.3.1 设计思路</strong></p><ul><li>自定义函数新增定义可以调用已定义的函数，这在架构中十分自然，因为HW2中解析函数等号之后的表达式我传入了一个空的Func类表示没有函数替换的可能性，在这次迭代中只需要将已经定义过的Func类传入Parser中辅助解析即可。</li><li>新增求导算子。如下图我在Expr中新增derivation属性，0代表不微分，1，2，3分别表示对x，y，z求偏微分。同时为每个基本类新增derivation方法，求导在解析完表达式并生成Poly之后调用，与生成Poly的过程类似，是递归调用的过程，尽头是Triangle, Number, Power这三个最底层的类，可直接求导，不需要再往下递归了。</li></ul><p><strong>2.3.2 UML类图</strong> </p><img src="/2023/03/15/2023-03-15-BUAA-OO-%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/3.png" class title="P3"><p><strong>2.3.3 类复杂度</strong></p><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Expr</td><td>1.5</td><td>4</td><td>9</td></tr><tr><td>Func</td><td>1.25</td><td>2</td><td>5</td></tr><tr><td>Lexer</td><td>2.75</td><td>7</td><td>11</td></tr><tr><td>MainClass</td><td>2.67</td><td>4</td><td>8</td></tr><tr><td>Number</td><td>1</td><td>1</td><td>4</td></tr><tr><td>Parser</td><td>5.8</td><td>10</td><td>29</td></tr><tr><td>Poly</td><td>4.71</td><td>14</td><td>80</td></tr><tr><td>Power</td><td>2.33</td><td>4</td><td>7</td></tr><tr><td>Special</td><td>1.31</td><td>3</td><td>17</td></tr><tr><td>Term</td><td>1.33</td><td>2</td><td>4</td></tr><tr><td>Triangle</td><td>1.67</td><td>2</td><td>5</td></tr></tbody></table><p>未增加任何类。新增的功能只需在Parser中增加解析求导算子，并且为表达式标记是否需要求导就能够实现。新增求导计算导致Poly的复杂度急剧增加，因为求导法则设计复杂的Poly计算，其方法调用更加频繁。</p><p><strong>2.3.4 方法复杂度</strong></p><table><thead><tr><th>Method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Expr.Expr()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.addTerm(Term, String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.createPoly()</td><td>5</td><td>1</td><td>4</td><td>4</td></tr><tr><td>Expr.getDerivation()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.setDerivation(int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.toString()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Func.Func(char,  ArrayList<Character>, Expr)</Character></td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Func.change(ArrayList<Factor>)</Factor></td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Func.getName()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Func.simplify(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.Lexer(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.getNumber()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Lexer.next()</td><td>12</td><td>2</td><td>9</td><td>11</td></tr><tr><td>Lexer.peek()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MainClass.createFunc(String,  ArrayList<Func>)</Func></td><td>6</td><td>1</td><td>4</td><td>4</td></tr><tr><td>MainClass.main(String[])</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>MainClass.simplify(String)</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Number.Number(BigInteger)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Number.addNumber(BigInteger)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Number.createPoly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Number.toString()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.Parser(Lexer,  ArrayList<Func>)</Func></td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.parseExpr()</td><td>16</td><td>1</td><td>9</td><td>9</td></tr><tr><td>Parser.parseFactor()</td><td>13</td><td>7</td><td>10</td><td>10</td></tr><tr><td>Parser.parseFunc()</td><td>4</td><td>3</td><td>4</td><td>4</td></tr><tr><td>Parser.parseTerm()</td><td>20</td><td>1</td><td>8</td><td>8</td></tr><tr><td>Poly.Poly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.addPoly(Poly, Poly)</td><td>4</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.cosDerivation(Special, int,  HashMap&lt;Special, BigInteger&gt;, HashMap&lt;Special, BigInteger&gt;)</td><td>19</td><td>1</td><td>7</td><td>7</td></tr><tr><td>Poly.derivation(int)</td><td>14</td><td>1</td><td>8</td><td>8</td></tr><tr><td>Poly.equals(Object)</td><td>3</td><td>3</td><td>2</td><td>4</td></tr><tr><td>Poly.getPolys()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.hashCode()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.merge()</td><td>8</td><td>1</td><td>5</td><td>5</td></tr><tr><td>Poly.mulPoly(Poly, Poly)</td><td>29</td><td>1</td><td>10</td><td>10</td></tr><tr><td>Poly.setPolys(HashMap&lt;Special,  BigInteger&gt;)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.sinDerivation(Special, int,  HashMap&lt;Special, BigInteger&gt;, HashMap&lt;Special, BigInteger&gt;)</td><td>19</td><td>1</td><td>7</td><td>7</td></tr><tr><td>Poly.subPoly(Poly, Poly)</td><td>4</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.toString()</td><td>34</td><td>8</td><td>23</td><td>24</td></tr><tr><td>Poly.tri(Special, String)</td><td>10</td><td>1</td><td>9</td><td>9</td></tr><tr><td>Poly.triesx(int)</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.triesy(int)</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.triesz(int)</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Power.Power(Integer, char)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Power.createPoly()</td><td>3</td><td>1</td><td>4</td><td>4</td></tr><tr><td>Power.toString()</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Special.clone()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Special.equals(Object)</td><td>4</td><td>3</td><td>6</td><td>8</td></tr><tr><td>Special.getCos()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.getSin()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.getX()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.getY()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.getZ()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.hashCode()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setCos(HashMap&lt;Poly,  Integer&gt;)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setSin(HashMap&lt;Poly,  Integer&gt;)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setX(Integer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setY(Integer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setZ(Integer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.Term()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.addFactor(Factor)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.createPoly()</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Triangle.Triangle(String, Expr, Integer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Triangle.createPoly()</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Triangle.toString()</td><td>1</td><td>1</td><td>2</td><td>2</td></tr></tbody></table><p>新增derivation方法，三角函数的derivation尤其复杂，因为我是用Hashmap来储存三角函数的内容（表达式）以及对应的指数的，求导过程中涉及深clone，程序的开销增加。</p><h2 id="三、BUG分析"><a href="#三、BUG分析" class="headerlink" title="三、BUG分析"></a>三、BUG分析</h2><ol><li>第一次作业评测与互测都没有出现bug，十分高兴。在hack他人的过程中将数据进行归类，空白字符夹杂，边界条件如0**0，压力测试等等，可惜均被room里的成员一一化解，room是一个平安夜状态。</li><li>第二次作业强测得分十分低，问题出在由于我第一次作业处理符号的时候是将Term与Term之间的符号存储在上一级Expr的Arraylist中，不给Term单独设置符号。在第二次作业的函数实参因子解析时候，我错误的用的是parseFactor，可能是我解析的是个因子，而因子的英文也是Factor的缘故吧，可惜如果其带负号，就会错误解析。改正方法是用parseExpr，直接把因子视作Expr。（哦悲悲，几个字母的区别）但好消息是互测体会到了狼人的快乐，快乐刀了14刀。同room的成员的bug有：<ul><li>将0**0直接字符串替换为1的，当10**0就会变成11，神奇</li><li>cos(1)**2*cos(1)**2合并为cos(1)**2**2的错误优化</li><li>sin(0)=1的数学错误</li><li>等等，记不太清了</li></ul></li><li>第三次作业强测错了一个点，虽说是一个点，但我很幸运。我在编写代码的时候，在三角函数求完导与未求导部分合并的时候居然不知为何地写成不管未求导部分系数为多少，均视其为1。这可能是个笔误，但中测互测居然没有发现，强测也仅仅错了一个点，有点感觉后背发凉以及无比庆幸。将其修正后就完美的结束了第三次作业。互测中，我只hack了三刀，分别对两位room成员发起：<ul><li>两位成员的bug相同，均为求导算子之后的表达式第一个符号没有储存。</li></ul></li><li>结合三次hack的经历，我认为比较好的策略是：<ul><li>尽量在自己设计的过程中记录可能出现的bug，并构造数据。</li><li>阅读他人代码，寻找薄弱处hack，例如高密度的正则表达式、字符串替换。</li><li>设计数据生成器及自动评测机，提高效率，但是应保证数据的覆盖性。</li></ul></li></ol><h2 id="五、心得体会"><a href="#五、心得体会" class="headerlink" title="五、心得体会"></a>五、心得体会</h2><p>首先感谢本次作业的过程中帮助我的同学和助教，今后面对更大更艰巨的任务与挑战大家还要继续加油。以下是我的体会以及反思。</p><ol><li><p>体会到了递归下降解析的强大，反复递归，使得面向对象的对象概念更加显著。过程式编程很难做到类似解析方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parser</span> &#123;</span><br><span class="line">    <span class="comment">//词法分析器</span></span><br><span class="line">    <span class="keyword">private</span> Lexer lexer;</span><br><span class="line">    <span class="comment">// parseExpr专门解析并返回Expr对象</span></span><br><span class="line">    <span class="keyword">public</span> ...<span class="comment">/*Expr对象*/</span> parseExpr() &#123;</span><br><span class="line">        <span class="comment">// 1、当前 Lexer 读到的是...</span></span><br><span class="line">        <span class="comment">// 2、循环读取 Lexer 的下一个词法</span></span><br><span class="line">        <span class="comment">//        若是...，则调用parseTerm</span></span><br><span class="line">        <span class="comment">//        若不是，则停止循环</span></span><br><span class="line">        <span class="comment">// 3、返回一个Expr对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//parseTerm专门解析并返回一个Term对象</span></span><br><span class="line">    <span class="keyword">public</span> ...<span class="comment">/*Term对象*/</span> parseTerm() &#123;</span><br><span class="line">        <span class="comment">// 1、当前 Lexer 读到的是...</span></span><br><span class="line">        <span class="comment">// 2、分类讨论 Lexer 之后读取的内容</span></span><br><span class="line">        <span class="comment">//        若是...，则...</span></span><br><span class="line">        <span class="comment">//        若是...，则...</span></span><br><span class="line">        <span class="comment">//        ...</span></span><br><span class="line">        <span class="comment">//        若是...，则调用parseFactor读取Factor对象作为组成部分</span></span><br><span class="line">        <span class="comment">// 3、返回一个Term对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// parseFactor专门解析并返回Factor对象</span></span><br><span class="line">    <span class="keyword">public</span> ...<span class="comment">/*数组对象*/</span> parseFactor() &#123;</span><br><span class="line">        <span class="comment">// 1、当前 Lexer 读到的是...</span></span><br><span class="line">        <span class="comment">// 2、循环读取 Lexer 的下一个词法</span></span><br><span class="line">        <span class="comment">//        若是...，则...</span></span><br><span class="line">        <span class="comment">//        若是...，则...</span></span><br><span class="line">        <span class="comment">//        ...</span></span><br><span class="line">        <span class="comment">// 3、返回一个Factor对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对我来说最最困难的是HW1的架构搭建，既要考虑以后的可能迭代，又要完成建立合适的类以及类之间的关系来完成本次作业，从过程式编程思想到面向对象编程思想的转变是十分困难的，也不是一下子能成功的，只有在不断地练习中去体会理解它。</p></li><li><p>虽然我完成了三次作业，但是对于性能分这一块</p></li><li><p>我并没有很好的解决方法去优化三角函数平方和的合并，以及高阶幂的降次。但是在第二次实验中我发现实验课上的<code>simplify</code>方法则十分适合处理该问题，可惜架构已经完成，我不愿意付出时间代价去重构，下次我需*更重视实验与作业结合。</p></li><li><p>数据自动生成与测试知识匮乏，无法搭建合适的评测机，需要向其他同学学习。</p></li></ol><p><strong>总而言之，OO是一门富有挑战性的课，在第一单元中我已经感受到了不知所措与迷茫，但这些挑战能在自己的深思熟虑，不断学习面向对象思想与改进固有思想后逐个解决，解决之后的成就感也是无法言说的。希望我能在未来更大更困难的挑战前也能如此。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一单元第一次作业</title>
      <link href="/2023/03/02/2020-03-01-%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
      <url>/2023/03/02/2020-03-01-%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="Homework-1"><a href="#Homework-1" class="headerlink" title="Homework 1"></a>Homework 1</h1><p>作业是对表达0式的去括号操作，步骤分为解析表达式和将表达式生成多项式。<br>整体uml类图：</p><img src="/2023/03/02/2020-03-01-%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A/3.png" class title="This is an example image"><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><ul><li>去除空格和’\t’</li><li>连续的加减化成一个，这个操作需要两次</li><li>**替换为^</li></ul><h1 id="递归下降解析表达式"><a href="#递归下降解析表达式" class="headerlink" title="递归下降解析表达式"></a>递归下降解析表达式</h1><h3 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h3><p>首先需要知道Number（整数）前面的正负号只会出现在*和^之后，其余情况把正负号作为Expr中连接Term（项）的加减号。所以lexer的解析步骤是：1.遇到数字调用getNumber().2.遇到正负号判断前一个字符是否满足上述要求，满足则作为数字处理，返回一个数字；不满足就只返回正负号。3.其余情况只返回当前pos位置的字符</p><h3 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h3><h4 id="递归解析表达式（Expr）"><a href="#递归解析表达式（Expr）" class="headerlink" title="递归解析表达式（Expr）"></a>递归解析表达式（Expr）</h4><ul><li><ol><li>读取到[+-]就add到expr储存符号的Arraylist，缺省为+.（符号与Term一一对应，仅代表连接Term的加减号）</li></ol></li><li><ol start="2"><li>解析项.</li></ol></li><li><ol start="3"><li>重复i，区别是如果一开始没有读到[+-]，则解析结束.</li></ol></li></ul><h4 id="递归解析项（Term）"><a href="#递归解析项（Term）" class="headerlink" title="递归解析项（Term）"></a>递归解析项（Term）</h4><ul><li><ol><li>解析因子Factor.</li></ol></li><li><ol start="2"><li>读取到的若不为^，则addFactor（），把因子加入Arraylist<Factor>里，若为^则继续读取指数，执行循环将（指数）次加入Arraylist<Factor>.</Factor></Factor></li></ol></li><li><ol start="3"><li>若读取的字符不是’*’则解析Term结束，否则重复i .</li></ol></li></ul><h4 id="递归解析因子（Factor）"><a href="#递归解析因子（Factor）" class="headerlink" title="递归解析因子（Factor）"></a>递归解析因子（Factor）</h4><ul><li><ol><li>读到括号进入表达式解析</li></ol></li><li><ol start="2"><li>读到’xyz’，返回幂函数（Power）</li></ol></li><li><ol start="3"><li>读到数字，返回数字（Number）</li></ol></li></ul><h1 id="表达式生成多项式"><a href="#表达式生成多项式" class="headerlink" title="表达式生成多项式"></a>表达式生成多项式</h1><h3 id="Special"><a href="#Special" class="headerlink" title="Special"></a>Special</h3><p>Special类仅有三个属性，分别存放x,y,z的指数。</p><h3 id="Poly"><a href="#Poly" class="headerlink" title="Poly"></a>Poly</h3><p>Poly属性值有HashMap&lt;Special, BigInteger&gt; polys，建立Special对BigInteger的映射。选择Hashmap的原因是其在多项式加减乘只需要对Hashmap做取并集类似操作，十分方便。</p><h2 id="createPoly-—–在每个类里都有一个createPoly-函数，递归生成表达式"><a href="#createPoly-—–在每个类里都有一个createPoly-函数，递归生成表达式" class="headerlink" title="createPoly()—–在每个类里都有一个createPoly()函数，递归生成表达式"></a>createPoly()—–在每个类里都有一个createPoly()函数，递归生成表达式</h2><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>（0，0，0）-&gt;num</p><h3 id="Power"><a href="#Power" class="headerlink" title="Power"></a>Power</h3><p>（*，0，0）-&gt;num  or（0，*，0）-&gt;num  or（0，0，*）-&gt;num ,*表示Power里存的x，y，z</p><h3 id="Term"><a href="#Term" class="headerlink" title="Term"></a>Term</h3><p>将Arraylist里的所有Factor生成的表达式相乘，调用mulPoly()</p><h3 id="Expr"><a href="#Expr" class="headerlink" title="Expr"></a>Expr</h3><p>将Arraylist里的所有Term生成的表达式根据相应Arraylist里的符号相加减，调用addPoly()或subPoly()</p><h1 id="整理表达式"><a href="#整理表达式" class="headerlink" title="整理表达式"></a>整理表达式</h1><p>Hashmap合并即可，最后整合一下输出。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汪亭臻是笨蛋的证明</title>
      <link href="/2023/01/09/2023-01-09-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/01/09/2023-01-09-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="汪亭臻是大笨蛋的证明"><a href="#汪亭臻是大笨蛋的证明" class="headerlink" title="汪亭臻是大笨蛋的证明"></a>汪亭臻是大笨蛋的证明</h1><h2 id="易证，略"><a href="#易证，略" class="headerlink" title="易证，略"></a>易证，略</h2>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
