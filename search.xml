<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2023-04-13-BUAA-OO-第一单元表达式解析</title>
      <link href="/2023/04/13/2023-04-13-BUAA-OO-%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E6%97%B6%E7%94%B5%E6%A2%AF%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/04/13/2023-04-13-BUAA-OO-%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E6%97%B6%E7%94%B5%E6%A2%AF%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="BUAA-OO-第二单元模拟多线程实时电梯系统"><a href="#BUAA-OO-第二单元模拟多线程实时电梯系统" class="headerlink" title="BUAA-OO-第二单元模拟多线程实时电梯系统"></a>BUAA-OO-第二单元模拟多线程实时电梯系统</h1><p>先贴类图</p><h2 id="HW5"><a href="#HW5" class="headerlink" title="HW5"></a>HW5</h2><img src="/2023/04/13/2023-04-13-BUAA-OO-%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E6%97%B6%E7%94%B5%E6%A2%AF%E7%B3%BB%E7%BB%9F/5.png" class title="P1"><h2 id="HW6"><a href="#HW6" class="headerlink" title="HW6"></a>HW6</h2><img src="/2023/04/13/2023-04-13-BUAA-OO-%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E6%97%B6%E7%94%B5%E6%A2%AF%E7%B3%BB%E7%BB%9F/6.png" class title="P2"><h2 id="HW7"><a href="#HW7" class="headerlink" title="HW7"></a>HW7</h2><img src="/2023/04/13/2023-04-13-BUAA-OO-%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E6%97%B6%E7%94%B5%E6%A2%AF%E7%B3%BB%E7%BB%9F/7.png" class title="P3"><h2 id="线程协作图"><a href="#线程协作图" class="headerlink" title="线程协作图"></a>线程协作图</h2><img src="/2023/04/13/2023-04-13-BUAA-OO-%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E6%97%B6%E7%94%B5%E6%A2%AF%E7%B3%BB%E7%BB%9F/1.png" class title="P4"><h2 id="1-同步块的设置和锁的选择，锁与同步块中处理语句之间的关系"><a href="#1-同步块的设置和锁的选择，锁与同步块中处理语句之间的关系" class="headerlink" title="1.同步块的设置和锁的选择，锁与同步块中处理语句之间的关系"></a>1.同步块的设置和锁的选择，锁与同步块中处理语句之间的关系</h2><ul><li>三次作业均为synchronized作为锁来实现同步互斥，至于锁和同步块之间的关系就是在一个同步块中，所有的语句都是受到同一个锁的保护的，这意味着只有拥有该锁的线程才能够执行同步块中的代码。因此，在同步块中的处理语句需要获取锁之后才能执行，如果在同步块中的某个处理语句执行过程中失去了锁，则其他线程有可能会抢占该锁并访问共享资源，从而导致线程安全问题。Platform作为共享对象，为了保证线程安全对其所有的方法用synchronized修饰。</li></ul><h2 id="2-三次作业中的调度器设计，调度器如何与程序中的线程进行交互"><a href="#2-三次作业中的调度器设计，调度器如何与程序中的线程进行交互" class="headerlink" title="2.三次作业中的调度器设计，调度器如何与程序中的线程进行交互"></a>2.三次作业中的调度器设计，调度器如何与程序中的线程进行交互</h2><h3 id="HW5-1"><a href="#HW5-1" class="headerlink" title="HW5"></a>HW5</h3><p>第一次作业使用了生产者-消费者模型，InputThread为生产者，Elevator为消费者，Platform为中间的channel，调度器为Schedule，从线程协作图可以看出第一次作业仅仅需要MainClass创建初始Elevator，并开启Elevator线程，开启InputThread和Schedule线程。InputThread产生Passenger给总的Platform，由Schedule进行调度，分配给每个电梯自己的Platform，第一次作业我的调度策略是分配给当前电梯Platform含有的Passenger最少的。调度器与Platform进行交互，负责放置Passenger，使用put()函数。Platform作为共享对象，为了保证线程安全对其所有的方法用synchronized修饰。最后每个Elevator就是一个消费者，从自己的Platform取Passenger，包括中途捎带也是对自己的Platform来说的。</p><h3 id="HW6-1"><a href="#HW6-1" class="headerlink" title="HW6"></a>HW6</h3><p>第二次作业在第一次作业的基础上增加了ADD和MAINTAIN电梯的要求，这在第一次作业的架构上只需要在InputThread里面新增需求进行相应处理就行了。ADD电梯可以new一个Platform给一个new出来的电梯，将Platform接受调度器的分配，再开启电梯的线程就完成了。MAINTAIN电梯只需要先把Platform设置为不接受调度器的分配，如何电梯收到信号，就近将电梯里的乘客修改From放到总Platform接受调度器的重新分配，电梯Platform里的乘客只需要放回总Platform接受重新分配即可。</p><h3 id="HW7-1"><a href="#HW7-1" class="headerlink" title="HW7"></a>HW7</h3><p>第三次作业在原有的架构上只需要为电梯设置每个楼层的可达性，在开门前进行判断，当电梯进行维护时需要特判。同时因为电梯不是每个楼层均可到达，要为乘客规划前往的路线，用数组储存乘客途径的楼层，至少保证数组第一个元素的准确性，其余的可以等乘客中途下电梯后重新进行规划。规划路线用的是Floyds算法，用Path记录途经楼层，使用算法前需要为楼层建图，使用的是邻接矩阵。作业还新增要求在每个楼层对开着门的电梯数和只接人的电梯数做出限定，我的处理方法是在开门条件新增判断，统计当前楼层处于这两种状态的电梯数，如果不满足则继续等待，等待到满足条件为止。相应的在电梯开关门和上下人时候要设置相应的值，来方便统计这两种状态。</p><h3 id="三次作业稳定的内容和易变的内容"><a href="#三次作业稳定的内容和易变的内容" class="headerlink" title="三次作业稳定的内容和易变的内容"></a>三次作业稳定的内容和易变的内容</h3><h4 id="稳定内容"><a href="#稳定内容" class="headerlink" title="稳定内容"></a>稳定内容</h4><ul><li>生产者消费者模型</li><li>调度器都是分配给电梯自己的Platform</li><li>电梯的运行行为</li><li>共享对象Platform的同步互斥</li></ul><h4 id="易变内容"><a href="#易变内容" class="headerlink" title="易变内容"></a>易变内容</h4><ul><li>电梯的开门条件判断</li><li>电梯MAINTAIN后状态的改变</li><li>调度器分配策略</li></ul><h2 id="3-bug分析"><a href="#3-bug分析" class="headerlink" title="3.bug分析"></a>3.bug分析</h2><p>HW6的bug在于要为每个电梯的Platform设置一个限度，不然当某一时刻请求量巨大，调度器完成分配后，新增电梯，但是由于已经完成分配，这些新增的电梯犹如摆设，会影响运行时间。解决方法就是为Platform设置限额，超过限额调度器就进行等待，等待新电梯的加入或者是Platform乘客的减少。debug方法为观察输出，进行推理，然后为新增的电梯的Platform设置println，获取乘客，发现为0，找到了问题。</p><p>HW7的bug在于MAINTAIN后也要符合每个楼层开门和只接人电梯数的限定，只需要增加特判即可。debug方法依然是通过观察输出，在关键处设置println来获取状态。由于多线程的缘故，用断点单步调试效果很差。</p><h2 id="4-心得体会"><a href="#4-心得体会" class="headerlink" title="4.心得体会"></a>4.心得体会</h2><ul><li>学会了生产者消费者模式，这些设计模式十分高效，做到了SOLID设计原则，高内聚低耦合十分适合移植使用，并且也十分形象。</li><li>多线程的安全问题永远值得我们取谨慎对待，尤其是在共享对象的处理上，可以先对所有的方法加上锁修饰，最后再去掉只读不写的方法的锁修饰。wait与notifyAll的使用也十分形象，但不能滥用notifyAll。</li><li>乘客的输入，调度器的设计，电梯的运行，这些模块各司其职，让我想到了流水线，只需要保证每个模块的正确性，在需求叠加时候只需要修改某几个模块，而不是“动一发而牵全身”，层次化的设计有助于迭代。</li><li>这单元的工作量相比于上个单元少了许多，代码量就能看出来，但是相应需要学习的知识却不少，学到了许多。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OS-Lab2</title>
      <link href="/2023/04/04/OS-Lab2/"/>
      <url>/2023/04/04/OS-Lab2/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab2实验报告"><a href="#Lab2实验报告" class="headerlink" title="Lab2实验报告"></a>Lab2实验报告</h1><h2 id="Thinkings"><a href="#Thinkings" class="headerlink" title="Thinkings"></a>Thinkings</h2><h3 id="Thingking2-1"><a href="#Thingking2-1" class="headerlink" title="Thingking2.1"></a>Thingking2.1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在编写的 C 程序中，指针变量中存储的地址是虚拟地址，还是物理地址？MIPS 汇编程序中 lw 和 sw 使用的是虚拟地址，还是物理地址？ </span><br></pre></td></tr></table></figure><p>均为虚拟地址，凡是用户编写的程序均使用的是虚拟地址，只有操作系统能直接与物理地址接触，用户与物理地址是不透明的。</p><h3 id="Thinking2-2"><a href="#Thinking2-2" class="headerlink" title="Thinking2.2"></a>Thinking2.2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从可重用性的角度，阐述用宏来实现链表的好处。</span><br></pre></td></tr></table></figure><p>修改时只需要修改宏定义，而不是多处修改，而且宏定义可读性强。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查看实验环境中的 /usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。</span><br></pre></td></tr></table></figure><p>实验中list是双向循环列表，结构体包含指向后一个节点的指针和指向前一个节点的后一个节点的指针的指针。tail为单向链表，包含tqh_first和tqh_last。</p><ul><li>单向链表的插入操作的时间复杂度为O(1)，删除操作的时间复杂度为O(n)。</li><li>循环链表的插入操作的时间复杂度为O(1)，删除操作的时间复杂度为O(n)。</li><li>双向链表的插入操作的时间复杂度为O(1)，删除操作的时间复杂度为O(1)。</li></ul><h3 id="Thinking2-3"><a href="#Thinking2-3" class="headerlink" title="Thinking2.3"></a>Thinking2.3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请阅读 include/queue.h 以及 include/pmap.h, 将 Page_list 的结构梳理清楚，选择正确的展开结构。</span><br></pre></td></tr></table></figure><p>观察pamp.h</p><img src="/2023/04/04/OS-Lab2/11.png" class title="P11"><img src="/2023/04/04/OS-Lab2/12.png" class title="P12"><p>把Page_list，Page代入宏LIST_HEAD,把Page代入宏LIST_ENTRY</p><img src="/2023/04/04/OS-Lab2/14.png" class title="P14"><p>最后将Page_list中的struct Page替换得答案，最后应该选c</p><img src="/2023/04/04/OS-Lab2/15.png" class title="P15"><h3 id="Thinking2-4"><a href="#Thinking2-4" class="headerlink" title="Thinking2.4"></a>Thinking2.4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请阅读上面有关 R3000-TLB 的叙述，从虚拟内存的实现角度，阐述 ASID 的必要性</span><br></pre></td></tr></table></figure><p><em><strong>ASID：Address Space IDentifier</strong></em> 用于区分不同的地址空间。查找 TLB 表项时，除了需要提供 VPN，还需要提供 ASID（同一虚拟地址在不同的地址空间中通常映射到不同的物理地址）。使用asid表明TLB中VPN的”身份”，可以在查TLB快表时候验证这个地址映射是否合法，若不合法及时中断可以达到数据保护的作用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请阅读《IDT R30xx Family Software Reference Manual》的 Chapter 6，结合 ASID段的位数，说明 R3000 中可容纳不同的地址空间的最大数量。</span><br></pre></td></tr></table></figure><p>ASID 为11-6位，共6位，容纳不同地址空间的最大数量为64(2^6)。</p><h3 id="Thinking2-5"><a href="#Thinking2-5" class="headerlink" title="Thinking2.5"></a>Thinking2.5</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">• tlb_invalidate 和 tlb_out 的调用关系？</span><br></pre></td></tr></table></figure><p><code>tlb_invalidate</code> 调用了<code>tlb_out</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">• 请用一句话概括 tlb_invalidate 的作用。</span><br></pre></td></tr></table></figure><p>Flush TLB。更新TLB表项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逐行解释 tlb_out 中的汇编代码。</span><br></pre></td></tr></table></figure><img src="/2023/04/04/OS-Lab2/2.png" class title="P2"><h3 id="Thinking2-6"><a href="#Thinking2-6" class="headerlink" title="Thinking2.6"></a>Thinking2.6</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">• 简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别。</span><br></pre></td></tr></table></figure><p>X86在TLB不命中时，MMU以CR3为页目录基址，转换得到物理页框号，MMU会填充TLB加快下次转换速度。<br>MIPS会触发TLB异常，内核的_do_tlb_refill会以导致缺页异常的虚拟地址查询页表，获得转换失败的物理页框号，并将其填入TLB。</p><h1 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h1><ul><li><p>要时时刻刻区分哪些是物理地址，哪些是虚拟地址</p></li><li><p>明确定义的函数的作用，比如PADDR和KADDR的区别</p></li><li><p>对于链表的掌握还不足，做链表填空花费了很多时间。</p></li><li><p>另外，理解Page结构体的结构，是本次实验比较大的一个难点。</p><img src="/2023/04/04/OS-Lab2/3.png" class title="P3"></li><li><p>两级页表的结构要清晰。</p><img src="/2023/04/04/OS-Lab2/6.png" class title="P6"></li><li><p>页目录自映射。</p></li><li><p>充填TLB的汇编代码</p></li></ul><h1 id="思考与体会"><a href="#思考与体会" class="headerlink" title="思考与体会"></a>思考与体会</h1><p>lab2补充了理论课，解决了部分理论课给我带来的困惑，尤其是听了理论课内存管理后，感觉似懂非懂，不知道自己是否真正掌握。遇到的第一个坎首先是Page结构体的理解，这个结构体不同于以前遇到的，指针的指针让我很不适应，实验后又重学了遍链表知识。第二个坎是page开头函数中对于物理地址与虚拟地址的混淆，准确来说是时而知道，时而模糊。还有就是TLB表项的概念，asid以及TLB汇编部分花了一定的时间去理解，最后终于看懂了指导书以及代码所描述的行为。但是关于TLB使用的汇编代码不是很熟练，并且对各个CP0寄存器的功能也不熟，希望能在lab3加深理解。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OS-Lab1</title>
      <link href="/2023/04/04/OS-Lab1/"/>
      <url>/2023/04/04/OS-Lab1/</url>
      
        <content type="html"><![CDATA[<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="Thinking-1-1"><a href="#Thinking-1-1" class="headerlink" title="Thinking 1.1"></a>Thinking 1.1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请阅读附录中的编译链接详解，尝试分别使用实验环境中的原生 x86 工具链（gcc、ld、readel f、objdump 等）和 MIPS 交叉编译工具链（带有 mips-linux-gnu前缀），重复其中的编译和解析过程，观察相应的结果，并解释其中向 objdump 传入的参数的含义。</span><br></pre></td></tr></table></figure><p><code>objdump</code>中参数：</p><p><code>-D</code>：从objfile中反汇编所有的section；</p><p><code>-S</code>：反汇编出源代码，与-g一起使用效果明显。</p><p>源代码在与预处理环节仅仅会进行字符串替换，在编译阶段对于不能确定地址的函数，但是又使用extern修饰的函数用一串0代替地址，只有在链接器将目标文件链接时，才会对那些函数地址进行填充，最后生成可执行文件。</p><h2 id="Thinking-1-2"><a href="#Thinking-1-2" class="headerlink" title="Thinking 1.2"></a>Thinking 1.2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">尝试使用我们编写的 readelf 程序，解析之前在 target 目录下生成的内核 ELF 文件。</span><br></pre></td></tr></table></figure><img src="/2023/04/04/OS-Lab1/1.png" class title="P1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也许你会发现我们编写的 readelf 程序是不能解析 readelf 文件本身的，而我们刚才介绍的系统工具 readelf 则可以解析，这是为什么呢？（提示：尝试使用 readelf-h，并阅读 tools/readelf 目录下的 Makefile，观察 readelf 与 hello 的不同）</span><br></pre></td></tr></table></figure><h3 id="hello"><a href="#hello" class="headerlink" title="hello"></a>hello</h3><img src="/2023/04/04/OS-Lab1/2.png" class title="P2"><h3 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h3><img src="/2023/04/04/OS-Lab1/3.png" class title="P3"><p>因为readelf是64位的elf文件，而hello是32位的elf文件。格式不同，而我们编写的readelf只能解析32位elf文件。</p><h2 id="Thinking-1-3"><a href="#Thinking-1-3" class="headerlink" title="Thinking 1.3"></a>Thinking 1.3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在理论课上我们了解到，MIPS 体系结构上电时，启动入口地址为 0xBFC00000（其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？（提示：思考实验中启动过程的两阶段分别由谁执行。） </span><br></pre></td></tr></table></figure><p>操作系统启动时，首先执行bootloader，在stage1阶段初始化硬件设备。MIPS处理器来说，MIPS体系结构上电时，启动入口的地址为某一个确定的地址，将这个虚拟地址的高三位清零之后的物理地址放置着开始MIPS的第一条指令，之后进入stage2阶段，BIOS从MBR中读取开机信息，然后将文件系统中的内核镜像文件加载到内存中，最后跳到指定的内核入口。</p><p>而我们的实验省去了bootloader，因此只需要将kernel镜像文件放置在正确的物理地址上，通过start.s跳转到正确的内核文件存放地址，之后就能安全执行。</p><h1 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h1><h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h2><ul><li>要了解ELF文件在编译和运行两种视角下的不同结构，节头表与段头表只是不同的展现视角，内容是一样的。</li><li>要理解ELF文件之中的三个结构体并利用文件头地址和偏移量求地址</li><li>我实验过程中比较困难的地方是没有读懂节头表结构体内数据的定义，一直在思考elf头结构体中的属性定义。</li></ul><h2 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h2><ul><li>注意是按照%[flags][width][length]&lt;specifier&gt;这样的顺序进行的，每次循环当作扫描到%处理，要重点理解代码中出现的函数的作用，搞清楚重要变量的作用，直到读到’\0’后才结束循环。注意要将padc，ladjust等标志作用的变量每循环一次都要清零，尤其是padc初值为’ ’，因为循环一次就表示读取并处理了一次%[flags][width][length]&lt;specifier&gt;形式。</li><li>处理可变参数里面数字是复数的情况，要传入负数的绝对值，再把neg_flag置为1。</li></ul><h1 id="思考与体会"><a href="#思考与体会" class="headerlink" title="思考与体会"></a>思考与体会</h1><p>lab1补充了理论课，解决了部分理论课给我带来的困惑，比如elf文件相关的知识，因为对这个知识点来说比较陌生，所以花费了不少的时间去理解。而第二个exercise的printk是考察大一C语言指针的使用，个人觉得与操作系统关系不大，加上注释写的比较详细，因此完成也不困难。但是变长参数的形式让我对printf等类似库函数有了进一步的理解，以前一直觉得库函数与我们自己写的函数是不一样的，因为我们自己写的函数要指定参数的个数与类型，而printf不需要，现在知道了可边长参数这一概念以后觉得豁然开朗。</p><p>这次实验也学到了很多，第一是关于Makefile的使用以及make和make clean的操作；第二是关于内核地址与MIPS的结合，.data和.text，学的不是很明白，经过lab1的学习明朗了很多，毕竟这俩在上学期的计组实验是频繁出现的，只是当时没有深入挖掘其含义。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OS-Lab0</title>
      <link href="/2023/04/04/OS-Lab0/"/>
      <url>/2023/04/04/OS-Lab0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OO 第一单元表达式解析</title>
      <link href="/2023/03/15/2023-03-15-BUAA-OO-%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/03/15/2023-03-15-BUAA-OO-%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><img src="/2023/03/15/2023-03-15-BUAA-OO-%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/problem.jpeg" class title="Problem"><h2 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h2><p>当我拿到第一次作业的时候，我不知所措，一开始不知道如何解析字符串，当理解了递归下降解析文法后，依然无法找到一种合适的方法去存储最基本的项，做不到最基础的（x+1)*(y+2)的计算，还记得那一次作业是在周六晚上才完成的，其中经历了许许多多的重构与折磨。OO要改变的是思维方式，这个过程是很漫长的，有很多方面都不适应，做出的重构就是思路的改变。仅以本博客记录记录我第一单元的经历。</p><h2 id="二、第一单元结构"><a href="#二、第一单元结构" class="headerlink" title="二、第一单元结构"></a>二、第一单元结构</h2><p><strong>2.1 HW1</strong></p><p><strong>2.1.1 设计思路</strong></p><ul><li>采用梯度下降的解析方法（<code>Paser</code>和<code>Lexer</code>）对表达式进行解析，整个表达式分为3层：<code>Expr</code>、<code>Term</code>、<code>Factor</code>，而Factor又包括<code>Number</code>、<code>Power</code>（幂函数）、<code>Expr</code>。</li><li>创建Poly类表示经过文法解析后的Expr，Term，Factor代表的数学多项式含义，Poly有一个Hashmap属性，Special储存了x,y,z的指数，通过将Special作为key映射到不同的value(系数)来储存多项式。通过createPoly()函数可以实例化一个Poly对象。</li><li>同时设置Power，Number类来表示最底层的类，这两个类能直接生成Poly类，而不需要递归调用内部因子的createPoly()函数。Expr生成Poly需要对组成Expr的每个Term调用createPoly()函数，最终把所有的Poly相加(addPoly())或相减(subPoly())</li><li>Term类生成Poly需要调用组成Term的Expr，Power，Number的createPoly()函数，而最终会递归到Power，Number，而这两个类是可以直接生成Poly的，因此不会进入无穷递归。最后把生成的Poly相乘，调用mulPoly()函数完成。</li><li>最后一步，在main里依次调用输入的字符串的递归下降解析，生成了一个Expr对象，再调用Expr的createPoly()方法，就能得到一个Poly的Hashmap，化简输出即完成了第一次作业。</li></ul><p><strong>2.1.2 UML类图</strong></p><img src="/2023/03/15/2023-03-15-BUAA-OO-%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/1.png" class title="P1"><p><strong>2.1.3 类复杂度</strong></p><h4 id="OCavg-Average-opearation-complexity（平均操作复杂度）"><a href="#OCavg-Average-opearation-complexity（平均操作复杂度）" class="headerlink" title="OCavg = Average opearation complexity（平均操作复杂度）"></a><code>OCavg</code> = <code>Average opearation complexity</code>（平均操作复杂度）</h4><h4 id="OCmax-Maximum-operation-complexity（最大操作复杂度）"><a href="#OCmax-Maximum-operation-complexity（最大操作复杂度）" class="headerlink" title="OCmax = Maximum operation complexity（最大操作复杂度）"></a><code>OCmax</code> = <code>Maximum operation complexity</code>（最大操作复杂度）</h4><h4 id="WMC-Weighted-method-complexity（加权方法复杂度）"><a href="#WMC-Weighted-method-complexity（加权方法复杂度）" class="headerlink" title="WMC = Weighted method complexity（加权方法复杂度）"></a><code>WMC</code> = <code>Weighted method complexity</code>（加权方法复杂度）</h4><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Expr</td><td>3.5</td><td>9</td><td>14</td></tr><tr><td>Lexer</td><td>2</td><td>5</td><td>10</td></tr><tr><td>MainClass</td><td>1</td><td>1</td><td>2</td></tr><tr><td>Number</td><td>1</td><td>1</td><td>3</td></tr><tr><td>Parser</td><td>5.25</td><td>8</td><td>21</td></tr><tr><td>Poly</td><td>2.43</td><td>5</td><td>17</td></tr><tr><td>Power</td><td>2.5</td><td>4</td><td>5</td></tr><tr><td>Special</td><td>1</td><td>1</td><td>7</td></tr><tr><td>Term</td><td>2.33</td><td>5</td><td>7</td></tr></tbody></table><p>从图中可以看出<code>Paser</code>和<code>Poly</code>的复杂度较高，这主要是因为程序可以分为解析和计算两大主要部分。解析部分主要由<code>Paser</code>实现，计算部分主要由<code>Poly</code>实现,承担大部分工作而造成的复杂度增加。</p><p><strong>2.1.4 方法复杂度</strong></p><p><strong><code>CogC</code> = <code>Cognitive complexity</code>（认知复杂度）</strong></p><h4 id="ev-G-Essential-cyclomatic-complexity（基本圈复杂度）"><a href="#ev-G-Essential-cyclomatic-complexity（基本圈复杂度）" class="headerlink" title="ev(G) = Essential cyclomatic complexity（基本圈复杂度）"></a><code>ev(G)</code> = <code>Essential cyclomatic complexity</code>（基本圈复杂度）</h4><h4 id="iv-G-Design-complexity（设计复杂度）"><a href="#iv-G-Design-complexity（设计复杂度）" class="headerlink" title="iv(G) = Design complexity（设计复杂度）"></a><code>iv(G)</code> = <code>Design complexity</code>（设计复杂度）</h4><h4 id="v-G-cyclonmatic-complexity（圈复杂度）"><a href="#v-G-cyclonmatic-complexity（圈复杂度）" class="headerlink" title="v(G) = cyclonmatic complexity（圈复杂度）"></a><code>v(G)</code> = <code>cyclonmatic complexity</code>（圈复杂度）</h4><table><thead><tr><th>Method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Expr.Expr()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.addTerm(Term, String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.createPoly()</td><td>4</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Expr.print()</td><td>24</td><td>1</td><td>11</td><td>12</td></tr><tr><td>Lexer.Lexer(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.behind()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.getNumber()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Lexer.next()</td><td>10</td><td>2</td><td>7</td><td>9</td></tr><tr><td>Lexer.peek()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MainClass.main(String[])</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MainClass.simplify(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Number.Number(BigInteger)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Number.addNumber(BigInteger)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Number.createPoly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.Parser(Lexer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.parseExpr()</td><td>16</td><td>1</td><td>9</td><td>9</td></tr><tr><td>Parser.parseFactor()</td><td>9</td><td>5</td><td>6</td><td>6</td></tr><tr><td>Parser.parseTerm()</td><td>20</td><td>1</td><td>8</td><td>8</td></tr><tr><td>Poly.Poly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.addPoly(Poly, Poly)</td><td>4</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.getPolys()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.merge()</td><td>8</td><td>1</td><td>5</td><td>5</td></tr><tr><td>Poly.mulPoly(Poly, Poly)</td><td>3</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.setPolys(HashMap&lt;Special,  BigInteger&gt;)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.subPoly(Poly, Poly)</td><td>4</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Power.Power(Integer, char)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Power.createPoly()</td><td>3</td><td>1</td><td>4</td><td>4</td></tr><tr><td>Special.equals(Special)</td><td>1</td><td>1</td><td>1</td><td>3</td></tr><tr><td>Special.getX()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.getY()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.getZ()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setX(Integer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setY(Integer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setZ(Integer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.Term()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.addFactor(Factor)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.createPoly()</td><td>5</td><td>1</td><td>5</td><td>5</td></tr></tbody></table><p>分析可知，<code>Expr.print()</code>和<code>Parser.parseTerm()</code>复杂度较高，解析项和因子情况比较复杂因此导致<code>Parser.parseTerm()</code>复杂度提升。而<code>Expr.print()</code>是因为我过程式编程思想没有完全摒弃导致的，在之后的迭代我将其优化为重写成各个类的<code>toString()</code>来输出结果。</p><p><strong>2.2 HW2</strong></p><p><strong>2.2.1 设计思路</strong></p><ul><li><h5 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h5><p>我选择在解析表达式之前建Func类来存自定义函数替换规则，之后在递归解析表达式过程中遇到自定义函数用字符串替换的方式去除自定义函数，返回表达式因子，为了保证运算优先级，替换后的因子加括号。比如,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">f(x,y)=x*y  (1)</span><br><span class="line">f(y,z)      (2)</span><br><span class="line">替换后    （y）*（z)</span><br></pre></td></tr></table></figure><p>但需要注意的是直接使用String的repalce会出现因为替换有先后顺序，会导致后一个替换<strong>错误替换</strong>前一个替换，例如上面例子，先把x-&gt;y,再把y-&gt;z，会先后得到(y)<em>y和((z))</em>(z)。因此可以为(2)式找一个与(1)式子没有交集的“自变量”，比如{h,j,k}来先替换(2)式中的{x,y,z}，最后完成因子替换后再换回。 <strong>注意，找无关变量不能太随意，比如找{a,b,c}，可能就会替换“cos”中的 ‘c’。</strong></p></li><li><h5 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h5><p>我选择将其作为与幂函数，整数同一“层面”的类，接口为Factor。 相比于上一次作业的架构，只需要将Poly给改进一下，使其能储存系数，x,y,z指数，三角函数及其指数，具体形式如下，可以考虑单独建一个类存x,y,z指数，和Hashmap映射三角函数与指数，再将这个类映射系数。</p><img src="/2023/03/15/2023-03-15-BUAA-OO-%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/4.png" class title="P4"></li></ul><p><strong>2.2.2 UML类图</strong></p><img src="/2023/03/15/2023-03-15-BUAA-OO-%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/2.png" class title="P2"><p><strong>2.2.3 类复杂度</strong></p><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Expr</td><td>1.5</td><td>3</td><td>6</td></tr><tr><td>Func</td><td>1.25</td><td>2</td><td>5</td></tr><tr><td>Lexer</td><td>2.75</td><td>7</td><td>11</td></tr><tr><td>MainClass</td><td>2.33</td><td>4</td><td>7</td></tr><tr><td>Number</td><td>1</td><td>1</td><td>4</td></tr><tr><td>Parser</td><td>6</td><td>11</td><td>30</td></tr><tr><td>Poly</td><td>4.38</td><td>14</td><td>57</td></tr><tr><td>Power</td><td>2.33</td><td>4</td><td>7</td></tr><tr><td>Special</td><td>1.17</td><td>3</td><td>14</td></tr><tr><td>Term</td><td>1.33</td><td>2</td><td>4</td></tr><tr><td>Triangle</td><td>1.67</td><td>2</td><td>5</td></tr></tbody></table><p>类新增了Triangle和Func类，复杂度均不高，因为只是新增了功能并不用承担很复杂的工作。由于调用是自顶向下的，最底层的Poly以及顶层的解析Parser这两个类的复杂度依然很高，这是架构设计导致的必然结果。</p><p><strong>2.2.4 方法复杂度</strong></p><table><thead><tr><th>Method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Expr.Expr()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.addTerm(Term, String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.createPoly()</td><td>4</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Expr.toString()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Func.Func(char,  ArrayList<Character>, Expr)</Character></td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Func.change(ArrayList<Factor>)</Factor></td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Func.getName()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Func.simplify(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.Lexer(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.getNumber()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Lexer.next()</td><td>12</td><td>2</td><td>9</td><td>11</td></tr><tr><td>Lexer.peek()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MainClass.createFunc(String)</td><td>6</td><td>1</td><td>4</td><td>4</td></tr><tr><td>MainClass.main(String[])</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>MainClass.simplify(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Number.Number(BigInteger)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Number.addNumber(BigInteger)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Number.createPoly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Number.toString()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.Parser(Lexer,  ArrayList<Func>)</Func></td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.parseExpr()</td><td>16</td><td>1</td><td>9</td><td>9</td></tr><tr><td>Parser.parseFactor()</td><td>16</td><td>8</td><td>11</td><td>11</td></tr><tr><td>Parser.parseFunc()</td><td>4</td><td>3</td><td>4</td><td>4</td></tr><tr><td>Parser.parseTerm()</td><td>20</td><td>1</td><td>8</td><td>8</td></tr><tr><td>Poly.Poly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.addPoly(Poly, Poly)</td><td>4</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.equals(Object)</td><td>3</td><td>3</td><td>2</td><td>4</td></tr><tr><td>Poly.hashCode()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.merge()</td><td>8</td><td>1</td><td>5</td><td>5</td></tr><tr><td>Poly.mulPoly(Poly, Poly)</td><td>29</td><td>1</td><td>10</td><td>10</td></tr><tr><td>Poly.setPolys(HashMap&lt;Special,  BigInteger&gt;)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.subPoly(Poly, Poly)</td><td>4</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.toString()</td><td>34</td><td>8</td><td>23</td><td>24</td></tr><tr><td>Poly.tri(Special, String)</td><td>10</td><td>1</td><td>9</td><td>9</td></tr><tr><td>Poly.triesx(int)</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.triesy(int)</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.triesz(int)</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Power.Power(Integer, char)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Power.createPoly()</td><td>3</td><td>1</td><td>4</td><td>4</td></tr><tr><td>Power.toString()</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Special.equals(Object)</td><td>4</td><td>3</td><td>6</td><td>8</td></tr><tr><td>Special.getCos()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.getSin()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.getX()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.getY()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.getZ()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.hashCode()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setCos(HashMap&lt;Poly,  Integer&gt;)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setSin(HashMap&lt;Poly,  Integer&gt;)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setX(Integer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setY(Integer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setZ(Integer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.Term()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.addFactor(Factor)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.createPoly()</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Triangle.Triangle(String, Expr, Integer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Triangle.createPoly()</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Triangle.toString()</td><td>1</td><td>1</td><td>2</td><td>2</td></tr></tbody></table><p><strong>2.3 HW3</strong></p><p><strong>2.3.1 设计思路</strong></p><ul><li>自定义函数新增定义可以调用已定义的函数，这在架构中十分自然，因为HW2中解析函数等号之后的表达式我传入了一个空的Func类表示没有函数替换的可能性，在这次迭代中只需要将已经定义过的Func类传入Parser中辅助解析即可。</li><li>新增求导算子。如下图我在Expr中新增derivation属性，0代表不微分，1，2，3分别表示对x，y，z求偏微分。同时为每个基本类新增derivation方法，求导在解析完表达式并生成Poly之后调用，与生成Poly的过程类似，是递归调用的过程，尽头是Triangle, Number, Power这三个最底层的类，可直接求导，不需要再往下递归了。</li></ul><p><strong>2.3.2 UML类图</strong> </p><img src="/2023/03/15/2023-03-15-BUAA-OO-%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/3.png" class title="P3"><p><strong>2.3.3 类复杂度</strong></p><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Expr</td><td>1.5</td><td>4</td><td>9</td></tr><tr><td>Func</td><td>1.25</td><td>2</td><td>5</td></tr><tr><td>Lexer</td><td>2.75</td><td>7</td><td>11</td></tr><tr><td>MainClass</td><td>2.67</td><td>4</td><td>8</td></tr><tr><td>Number</td><td>1</td><td>1</td><td>4</td></tr><tr><td>Parser</td><td>5.8</td><td>10</td><td>29</td></tr><tr><td>Poly</td><td>4.71</td><td>14</td><td>80</td></tr><tr><td>Power</td><td>2.33</td><td>4</td><td>7</td></tr><tr><td>Special</td><td>1.31</td><td>3</td><td>17</td></tr><tr><td>Term</td><td>1.33</td><td>2</td><td>4</td></tr><tr><td>Triangle</td><td>1.67</td><td>2</td><td>5</td></tr></tbody></table><p>未增加任何类。新增的功能只需在Parser中增加解析求导算子，并且为表达式标记是否需要求导就能够实现。新增求导计算导致Poly的复杂度急剧增加，因为求导法则设计复杂的Poly计算，其方法调用更加频繁。</p><p><strong>2.3.4 方法复杂度</strong></p><table><thead><tr><th>Method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Expr.Expr()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.addTerm(Term, String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.createPoly()</td><td>5</td><td>1</td><td>4</td><td>4</td></tr><tr><td>Expr.getDerivation()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.setDerivation(int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Expr.toString()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Func.Func(char,  ArrayList<Character>, Expr)</Character></td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Func.change(ArrayList<Factor>)</Factor></td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Func.getName()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Func.simplify(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.Lexer(String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Lexer.getNumber()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Lexer.next()</td><td>12</td><td>2</td><td>9</td><td>11</td></tr><tr><td>Lexer.peek()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>MainClass.createFunc(String,  ArrayList<Func>)</Func></td><td>6</td><td>1</td><td>4</td><td>4</td></tr><tr><td>MainClass.main(String[])</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>MainClass.simplify(String)</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Number.Number(BigInteger)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Number.addNumber(BigInteger)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Number.createPoly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Number.toString()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.Parser(Lexer,  ArrayList<Func>)</Func></td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Parser.parseExpr()</td><td>16</td><td>1</td><td>9</td><td>9</td></tr><tr><td>Parser.parseFactor()</td><td>13</td><td>7</td><td>10</td><td>10</td></tr><tr><td>Parser.parseFunc()</td><td>4</td><td>3</td><td>4</td><td>4</td></tr><tr><td>Parser.parseTerm()</td><td>20</td><td>1</td><td>8</td><td>8</td></tr><tr><td>Poly.Poly()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.addPoly(Poly, Poly)</td><td>4</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.cosDerivation(Special, int,  HashMap&lt;Special, BigInteger&gt;, HashMap&lt;Special, BigInteger&gt;)</td><td>19</td><td>1</td><td>7</td><td>7</td></tr><tr><td>Poly.derivation(int)</td><td>14</td><td>1</td><td>8</td><td>8</td></tr><tr><td>Poly.equals(Object)</td><td>3</td><td>3</td><td>2</td><td>4</td></tr><tr><td>Poly.getPolys()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.hashCode()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.merge()</td><td>8</td><td>1</td><td>5</td><td>5</td></tr><tr><td>Poly.mulPoly(Poly, Poly)</td><td>29</td><td>1</td><td>10</td><td>10</td></tr><tr><td>Poly.setPolys(HashMap&lt;Special,  BigInteger&gt;)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Poly.sinDerivation(Special, int,  HashMap&lt;Special, BigInteger&gt;, HashMap&lt;Special, BigInteger&gt;)</td><td>19</td><td>1</td><td>7</td><td>7</td></tr><tr><td>Poly.subPoly(Poly, Poly)</td><td>4</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.toString()</td><td>34</td><td>8</td><td>23</td><td>24</td></tr><tr><td>Poly.tri(Special, String)</td><td>10</td><td>1</td><td>9</td><td>9</td></tr><tr><td>Poly.triesx(int)</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.triesy(int)</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Poly.triesz(int)</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Power.Power(Integer, char)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Power.createPoly()</td><td>3</td><td>1</td><td>4</td><td>4</td></tr><tr><td>Power.toString()</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Special.clone()</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>Special.equals(Object)</td><td>4</td><td>3</td><td>6</td><td>8</td></tr><tr><td>Special.getCos()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.getSin()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.getX()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.getY()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.getZ()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.hashCode()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setCos(HashMap&lt;Poly,  Integer&gt;)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setSin(HashMap&lt;Poly,  Integer&gt;)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setX(Integer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setY(Integer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Special.setZ(Integer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.Term()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.addFactor(Factor)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Term.createPoly()</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Triangle.Triangle(String, Expr, Integer)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Triangle.createPoly()</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>Triangle.toString()</td><td>1</td><td>1</td><td>2</td><td>2</td></tr></tbody></table><p>新增derivation方法，三角函数的derivation尤其复杂，因为我是用Hashmap来储存三角函数的内容（表达式）以及对应的指数的，求导过程中涉及深clone，程序的开销增加。</p><h2 id="三、BUG分析"><a href="#三、BUG分析" class="headerlink" title="三、BUG分析"></a>三、BUG分析</h2><ol><li>第一次作业评测与互测都没有出现bug，十分高兴。在hack他人的过程中将数据进行归类，空白字符夹杂，边界条件如0**0，压力测试等等，可惜均被room里的成员一一化解，room是一个平安夜状态。</li><li>第二次作业强测得分十分低，问题出在由于我第一次作业处理符号的时候是将Term与Term之间的符号存储在上一级Expr的Arraylist中，不给Term单独设置符号。在第二次作业的函数实参因子解析时候，我错误的用的是parseFactor，可能是我解析的是个因子，而因子的英文也是Factor的缘故吧，可惜如果其带负号，就会错误解析。改正方法是用parseExpr，直接把因子视作Expr。（哦悲悲，几个字母的区别）但好消息是互测体会到了狼人的快乐，快乐刀了14刀。同room的成员的bug有：<ul><li>将0**0直接字符串替换为1的，当10**0就会变成11，神奇</li><li>cos(1)**2*cos(1)**2合并为cos(1)**2**2的错误优化</li><li>sin(0)=1的数学错误</li><li>等等，记不太清了</li></ul></li><li>第三次作业强测错了一个点，虽说是一个点，但我很幸运。我在编写代码的时候，在三角函数求完导与未求导部分合并的时候居然不知为何地写成不管未求导部分系数为多少，均视其为1。这可能是个笔误，但中测互测居然没有发现，强测也仅仅错了一个点，有点感觉后背发凉以及无比庆幸。将其修正后就完美的结束了第三次作业。互测中，我只hack了三刀，分别对两位room成员发起：<ul><li>两位成员的bug相同，均为求导算子之后的表达式第一个符号没有储存。</li></ul></li><li>结合三次hack的经历，我认为比较好的策略是：<ul><li>尽量在自己设计的过程中记录可能出现的bug，并构造数据。</li><li>阅读他人代码，寻找薄弱处hack，例如高密度的正则表达式、字符串替换。</li><li>设计数据生成器及自动评测机，提高效率，但是应保证数据的覆盖性。</li></ul></li></ol><h2 id="五、心得体会"><a href="#五、心得体会" class="headerlink" title="五、心得体会"></a>五、心得体会</h2><p>首先感谢本次作业的过程中帮助我的同学和助教，今后面对更大更艰巨的任务与挑战大家还要继续加油。以下是我的体会以及反思。</p><ol><li><p>体会到了递归下降解析的强大，反复递归，使得面向对象的对象概念更加显著。过程式编程很难做到类似解析方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parser</span> &#123;</span><br><span class="line">    <span class="comment">//词法分析器</span></span><br><span class="line">    <span class="keyword">private</span> Lexer lexer;</span><br><span class="line">    <span class="comment">// parseExpr专门解析并返回Expr对象</span></span><br><span class="line">    <span class="keyword">public</span> ...<span class="comment">/*Expr对象*/</span> parseExpr() &#123;</span><br><span class="line">        <span class="comment">// 1、当前 Lexer 读到的是...</span></span><br><span class="line">        <span class="comment">// 2、循环读取 Lexer 的下一个词法</span></span><br><span class="line">        <span class="comment">//        若是...，则调用parseTerm</span></span><br><span class="line">        <span class="comment">//        若不是，则停止循环</span></span><br><span class="line">        <span class="comment">// 3、返回一个Expr对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//parseTerm专门解析并返回一个Term对象</span></span><br><span class="line">    <span class="keyword">public</span> ...<span class="comment">/*Term对象*/</span> parseTerm() &#123;</span><br><span class="line">        <span class="comment">// 1、当前 Lexer 读到的是...</span></span><br><span class="line">        <span class="comment">// 2、分类讨论 Lexer 之后读取的内容</span></span><br><span class="line">        <span class="comment">//        若是...，则...</span></span><br><span class="line">        <span class="comment">//        若是...，则...</span></span><br><span class="line">        <span class="comment">//        ...</span></span><br><span class="line">        <span class="comment">//        若是...，则调用parseFactor读取Factor对象作为组成部分</span></span><br><span class="line">        <span class="comment">// 3、返回一个Term对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// parseFactor专门解析并返回Factor对象</span></span><br><span class="line">    <span class="keyword">public</span> ...<span class="comment">/*数组对象*/</span> parseFactor() &#123;</span><br><span class="line">        <span class="comment">// 1、当前 Lexer 读到的是...</span></span><br><span class="line">        <span class="comment">// 2、循环读取 Lexer 的下一个词法</span></span><br><span class="line">        <span class="comment">//        若是...，则...</span></span><br><span class="line">        <span class="comment">//        若是...，则...</span></span><br><span class="line">        <span class="comment">//        ...</span></span><br><span class="line">        <span class="comment">// 3、返回一个Factor对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对我来说最最困难的是HW1的架构搭建，既要考虑以后的可能迭代，又要完成建立合适的类以及类之间的关系来完成本次作业，从过程式编程思想到面向对象编程思想的转变是十分困难的，也不是一下子能成功的，只有在不断地练习中去体会理解它。</p></li><li><p>虽然我完成了三次作业，但是对于性能分这一块，我并没有很好的解决方法去优化三角函数平方和的合并，以及高阶幂的降次。但是在第二次实验中我发现实验课上的<code>simplify</code>方法则十分适合处理该问题，可惜架构已经完成，我不愿意付出时间代价去重构，下次我需*更重视实验与作业结合。</p></li><li><p>数据自动生成与测试知识匮乏，无法搭建合适的评测机，需要向其他同学学习。</p></li></ol><p><strong>总而言之，OO是一门富有挑战性的课，在第一单元中我已经感受到了不知所措与迷茫，但这些挑战能在自己的深思熟虑，不断学习面向对象思想与改进固有思想后逐个解决，解决之后的成就感也是无法言说的。希望我能在未来更大更困难的挑战前也能如此。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一单元第一次作业</title>
      <link href="/2023/03/02/2023-03-01-%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
      <url>/2023/03/02/2023-03-01-%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="Homework-1"><a href="#Homework-1" class="headerlink" title="Homework 1"></a>Homework 1</h1><p>作业是对表达0式的去括号操作，步骤分为解析表达式和将表达式生成多项式。<br>整体uml类图：</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><ul><li>去除空格和’\t’</li><li>连续的加减化成一个，这个操作需要两次</li><li>**替换为^</li></ul><h1 id="递归下降解析表达式"><a href="#递归下降解析表达式" class="headerlink" title="递归下降解析表达式"></a>递归下降解析表达式</h1><h3 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h3><p>首先需要知道Number（整数）前面的正负号只会出现在*和^之后，其余情况把正负号作为Expr中连接Term（项）的加减号。所以lexer的解析步骤是：1.遇到数字调用getNumber().2.遇到正负号判断前一个字符是否满足上述要求，满足则作为数字处理，返回一个数字；不满足就只返回正负号。3.其余情况只返回当前pos位置的字符</p><h3 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h3><h4 id="递归解析表达式（Expr）"><a href="#递归解析表达式（Expr）" class="headerlink" title="递归解析表达式（Expr）"></a>递归解析表达式（Expr）</h4><ul><li><ol><li>读取到[+-]就add到expr储存符号的Arraylist，缺省为+.（符号与Term一一对应，仅代表连接Term的加减号）</li></ol></li><li><ol start="2"><li>解析项.</li></ol></li><li><ol start="3"><li>重复i，区别是如果一开始没有读到[+-]，则解析结束.</li></ol></li></ul><h4 id="递归解析项（Term）"><a href="#递归解析项（Term）" class="headerlink" title="递归解析项（Term）"></a>递归解析项（Term）</h4><ul><li><ol><li>解析因子Factor.</li></ol></li><li><ol start="2"><li>读取到的若不为^，则addFactor（），把因子加入Arraylist<Factor>里，若为^则继续读取指数，执行循环将（指数）次加入Arraylist<Factor>.</Factor></Factor></li></ol></li><li><ol start="3"><li>若读取的字符不是’*’则解析Term结束，否则重复i .</li></ol></li></ul><h4 id="递归解析因子（Factor）"><a href="#递归解析因子（Factor）" class="headerlink" title="递归解析因子（Factor）"></a>递归解析因子（Factor）</h4><ul><li><ol><li>读到括号进入表达式解析</li></ol></li><li><ol start="2"><li>读到’xyz’，返回幂函数（Power）</li></ol></li><li><ol start="3"><li>读到数字，返回数字（Number）</li></ol></li></ul><h1 id="表达式生成多项式"><a href="#表达式生成多项式" class="headerlink" title="表达式生成多项式"></a>表达式生成多项式</h1><h3 id="Special"><a href="#Special" class="headerlink" title="Special"></a>Special</h3><p>Special类仅有三个属性，分别存放x,y,z的指数。</p><h3 id="Poly"><a href="#Poly" class="headerlink" title="Poly"></a>Poly</h3><p>Poly属性值有HashMap&lt;Special, BigInteger&gt; polys，建立Special对BigInteger的映射。选择Hashmap的原因是其在多项式加减乘只需要对Hashmap做取并集类似操作，十分方便。</p><h2 id="createPoly-—–在每个类里都有一个createPoly-函数，递归生成表达式"><a href="#createPoly-—–在每个类里都有一个createPoly-函数，递归生成表达式" class="headerlink" title="createPoly()—–在每个类里都有一个createPoly()函数，递归生成表达式"></a>createPoly()—–在每个类里都有一个createPoly()函数，递归生成表达式</h2><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>（0，0，0）-&gt;num</p><h3 id="Power"><a href="#Power" class="headerlink" title="Power"></a>Power</h3><p>（*，0，0）-&gt;num  or（0，*，0）-&gt;num  or（0，0，*）-&gt;num ,*表示Power里存的x，y，z</p><h3 id="Term"><a href="#Term" class="headerlink" title="Term"></a>Term</h3><p>将Arraylist里的所有Factor生成的表达式相乘，调用mulPoly()</p><h3 id="Expr"><a href="#Expr" class="headerlink" title="Expr"></a>Expr</h3><p>将Arraylist里的所有Term生成的表达式根据相应Arraylist里的符号相加减，调用addPoly()或subPoly()</p><h1 id="整理表达式"><a href="#整理表达式" class="headerlink" title="整理表达式"></a>整理表达式</h1><p>Hashmap合并即可，最后整合一下输出。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汪亭臻是笨蛋的证明</title>
      <link href="/2023/01/09/2023-01-09-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/01/09/2023-01-09-%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="汪亭臻是大笨蛋的证明"><a href="#汪亭臻是大笨蛋的证明" class="headerlink" title="汪亭臻是大笨蛋的证明"></a>汪亭臻是大笨蛋的证明</h1><h2 id="易证，略"><a href="#易证，略" class="headerlink" title="易证，略"></a>易证，略</h2>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
